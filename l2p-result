#!/bin/bash
#
# ./l2p-result
#
# L2P Protocol Analyzer (result from L2P device is analyzed)
#
# to get help, use ./l2p-result -h
#
# (c) 2012, Ondics GmbH | githubler@ondics.de | www.ondics.de
#
# This program is dual licensed under commercial and GPL Version 3
# licenses. For commercial license conditions please contact us.
# As free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#

self="${0##*/}"
install_dir="/usr/share/lufft-l2p-script-collection"

# read local environment
if [ -e "$install_dir/local_env" ];then
    source "$install_dir/local_env"
    PATH="$PATH:$dir_scripts"
else
    echo "error: install_dir not set correctly"
    exit 1
fi

error() {
	local msg="$1"
	printf "%s: %s\nTry '%s --help' for more information\n" \
	       "$self" "$msg" "$self" >&2
	exit 1
}
usage() {
	printf "Interprets L2P Result\n\n"
	printf "Usage: %s [-f <file>] [-h]\n\n" "$self"
	printf "file contains input from previous request.\n"
        printf "Options:\n"
        printf "    -h | --help          this little help\n"        
        printf "    -v | --verbose       talk about what's going on\n"
        printf "    -f | --file <file>   read input from <file>\n"
        printf "    -a | --ascii         read input in ascii hex mode (e.g. 'FA 03')\n"
	exit
}

# default values
verbose=0
ascii_input=0
file=""                 
while [[ $# -gt 0 ]]; do
	arg="$1"; shift	
	case "$arg" in
	-h|--help  ) usage                              ;;
        -v|--verbose) verbose=1                         ;;
        -a|--ascii)  ascii_input=1                      ;;
        -f|--file  ) file="$1"         ; done=1 ; break ;;
	--         ) string="$1"                ; break ;;
	-          ) string=$( cat )   ; done=1 ; break ;;
	-*         ) error "unrecognized option '$arg'" ;;
	*          ) string="$arg"     ; done=1 ; break ;;
	esac
done

if [ -n $file ]; then
    if [ -e $file ]; then
        if [ $ascii_input -eq 0 ];  then
            string=$( hexdump -v -e '"" 1/1 "%02X" " "' $file )
        else
            string=$( cat $file )
        fi
    else
        error "sorry, file not found."
    fi
else
    if [ $ascii_input -eq 0 ];  then
        string=$( hexdump -v -e '"" 1/1 "%02X" " "' )
    else
        string=$( cat )
    fi 
fi
[[ "$done" || "$string" ]] || string=$( hexdump -v -e '"" 1/1 "%02X" " "' )

[[ "$string" ]] || error "sorry, no input."

[[ $verbose == 1 ]] && printf "Interpreting L2P-Result=[$string]\n" > /dev/stderr

# Expected command-line behaviour table:
# <none>    => str = stdin
# -         => str = stdin
# something => str = something
# -- <none> => str = stdin
# -- someth => str = something

# example string:
# 01 10 00 00 00 00 03 02 23 10 24 03 07 28 04
# ---header------- len stx(02)
#                        cmd verc
#                               payloay (abh. von len)
#                                  etx(03) chksum eot(04)
# payload: erstes zeichen ist status

# check header
if [ "${string:0:17}" != "01 10 00 00 00 00" ]; then error "l2p-header incorrect"; fi

# length of payload
len=$(printf "%d" "0x${string:18:2}")
[[ $verbose == 1 ]] && printf "length of payload=%d\n"  "$len"

# stx ok?
if [ "${string:21:2}" != "02" ]; then error "l2p-stx incorrect"; fi

# cmd/verc
cmd=${string:8*3:2}
verc=${string:9*3:2}
[[ $verbose == 1 ]] && printf "CMD=[%s] VERC=[%s]\n"  "$cmd" "$verc"

# payload
payload="${string:10*3:2+(len-3)*3}"
[[ $verbose == 1 ]] && printf "Payload=[%s]\n" "$payload"

# etx ok?
if [ "${string:(8+len)*3:2}" != "03" ]; then error "l2p-stx incorrect"; fi

# chksum ok?
frame="${string:0:(9+len)*3-1}"
chksum_calc=$($dir_scripts/l2p-crc16 "$frame")
chksum_found="${string:(9+len)*3:5}"
[[ "$chksum_calc" != "$chksum_found" ]] && printf "warning: l2p chksum incorrect: %s!\n" "$chksum_calc"
[[ $verbose == 1 && "$chksum_calc" == "$chksum_found" ]] && printf "Checksum: OK\n"

# eot ok?
if [ "${string:(11+len)*3:2}" != "04" ]; then error "l2p-eot incorrect"; fi

# now analyze payload!
# first check status
l2p_status_short[0x00]="OK"; l2p_status_long[0x00]="Kommando erfolgreich";
l2p_status_short[0x10]="UNKNOWN_CMD"; l2p_status_long[0x10]="unbekanntes Kommando";
l2p_status_short[0x11]="INVALID_PARAM"; l2p_status_long[0x11]="ungültige Parameter";
l2p_status_short[0x12]="INVALID_HEADER"; l2p_status_long[0x12]="ungültige Header-Version";
l2p_status_short[0x13]="INVALID_VERC"; l2p_status_long[0x13]="ungültige Version des Befehls";
l2p_status_short[0x14]="INVALID_PW"; l2p_status_long[0x14]="Passwort für Kommando falsch";
l2p_status_short[0x20]="READ_ERR"; l2p_status_long[0x20]="Lesefehler";
l2p_status_short[0x21]="WRITE_ERR"; l2p_status_long[0x21]="Schreibfehler";
l2p_status_short[0x22]="TOO_LONG"; l2p_status_long[0x22]="Zu lang";
l2p_status_short[0x23]="INVALID_ADDRESS"; l2p_status_long[0x23]="ungültige Adresse";
l2p_status_short[0x24]="INVALID_CHANNEL"; l2p_status_long[0x24]="ungültiger Kanal";
l2p_status_short[0x25]="INVALID_CMD"; l2p_status_long[0x25]="Kommando in diesem Modus nicht möglich";
l2p_status_short[0x26]="UNKNOWN_CAL_CMD"; l2p_status_long[0x26]="unbekanntes Abgleich-Kommando";
l2p_status_short[0x27]="CAL_ERROR"; l2p_status_long[0x27]="Fehler bei der Kalibrierung";
l2p_status_short[0x28]="BUSY"; l2p_status_long[0x28]="Busy";
l2p_status_short[0x29]="LOW_VOLTAGE"; l2p_status_long[0x29]="Unterspannung";
l2p_status_short[0x2A]="HW_ERROR"; l2p_status_long[0x2A]="Hardwarefehler";
l2p_status_short[0x2B]="MEAS_ERROR"; l2p_status_long[0x2B]="Fehler in der Messung";
l2p_status_short[0x2C]="INIT_ERROR"; l2p_status_long[0x2C]="Fehler bei der Geräteinitialisierung";
l2p_status_short[0x2D]="OS_ERROR"; l2p_status_long[0x2D]="Fehler im Betriebssystem";
l2p_status_short[0x30]="E2_DEFAULT_KONF"; l2p_status_long[0x30]="Fehler, Default-Konfiguration wurde geladen";
l2p_status_short[0x31]="E2_CAL_ERROR"; l2p_status_long[0x31]="Abgleich ist ungültig, Messung nicht möglich";
l2p_status_short[0x32]="E2_CRC_KONF_ERR"; l2p_status_long[0x32]="CRC-Fehler, Default-Konfiguration geladen";
l2p_status_short[0x33]="E2_CRC_KAL_ERR"; l2p_status_long[0x33]="CRC-Fehler Abgleich-Daten, Messung nicht möglich";
l2p_status_short[0x34]="ADJ_STEP1"; l2p_status_long[0x34]="Abgleich Step 1";
l2p_status_short[0x35]="ADJ_OK"; l2p_status_long[0x35]="Abgleich OK";
l2p_status_short[0x36]="CHANNEL_OFF"; l2p_status_long[0x36]="Kanal deaktiviert";
l2p_status_short[0x50]="VALUE_OVERFLOW"; l2p_status_long[0x50]="Messgröße (+Offset) liegt außerhalb des eingestellten Darstellungsbereichs";
l2p_status_short[0x51]="VALUE_UNDERFLOW"; l2p_status_long[0x51]="";
l2p_status_short[0x52]="CHANNEL_OVERRANGE"; l2p_status_long[0x52]="Messwert (physikalisch) liegt außerhalb des Messbereichs (z.B. ADC-Overrange)  ";
l2p_status_short[0x53]="CHANNEL_UNDERRANGE"; l2p_status_long[0x53]="";
l2p_status_short[0x54]="DATA_ERROR"; l2p_status_long[0x54]="Messdaten ungültig oder nicht vorhanden";
l2p_status_short[0x55]="MEAS_UNABLE"; l2p_status_long[0x55]="Umgebungsbedingung! Keine Messung möglich";
l2p_status_short[0x60]="FLASH_CRC_ERR"; l2p_status_long[0x60]="CRC-Fehler in den Flash-Daten";
l2p_status_short[0x61]="FLASH_WRITE_ERR"; l2p_status_long[0x61]="Fehler beim Schreiben ins Flash";
l2p_status_short[0x62]="FLASH_FLOAT_ERR"; l2p_status_long[0x62]="Flash enthält ungültige Float-Werte";
l2p_status_short[0x80]="FW_RECEIVE_ERR"; l2p_status_long[0x80]="Firmwareübertragungsmodus nicht möglich";
l2p_status_short[0x81]="CRC_ERR"; l2p_status_long[0x81]="CRC Fehler";
l2p_status_short[0x82]="TIMEOUT_ERR"; l2p_status_long[0x82]="Zeitfenster abgelaufen";
l2p_status_short[0xF0]="Reserviert"; l2p_status_long[0xF0]="Reserviert";
l2p_status_short[0xFF]="UNKNOWN_ERR"; l2p_status_long[0xFF]="unbekannter Fehler";

status=$(printf "%d" "0x${payload:0:2}")
[[ $verbose == 1 ]] && printf "Status: %s (%s)\n" "${l2p_status_short[$status]}" "${l2p_status_long[$status]}"
[[ $status -ne 0 ]] && error "error: status not ok"
    
if [ $len -le 3 ]; then exit; fi

[[ $verbose == 1 ]] && printf "Rest-Payload=[%s]\n" "${payload:3}"

# then check channel output
kanal_spec[100]="AKT temperature min=-20.0 max=50.0 unit=°C type=FLOAT offset=±10.0"
kanal_spec[120]="MIN temperature min=-20.0 max=50.0 unit=°C type=FLOAT offset=±10.0"
kanal_spec[140]="MAX temperature min=-20.0 max=50.0 unit=°C type=FLOAT offset=±10.0"
kanal_spec[160]="AVG temperature min=-20.0 max=50.0 unit=°C type=FLOAT offset=±10.0"
kanal_spec[105]="AKT temperature min=-4.0 max=122.0 unit=°F type=FLOAT offset=0.0"
kanal_spec[125]="MIN temperature min=-4.0 max=122.0 unit=°F type=FLOAT offset=0.0"
kanal_spec[145]="MAX temperature min=-4.0 max=122.0 unit=°F type=FLOAT offset=0.0"
kanal_spec[165]="AVG temperature min=-4.0 max=122.0 unit=°F type=FLOAT offset=0.0"
kanal_spec[110]="AKT dewpoint min=-85.0 max=50.0 unit=°C type=FLOAT offset=0.0"
kanal_spec[130]="MIN dewpoint min=-85.0 max=50.0 unit=°C type=FLOAT offset=0.0"
kanal_spec[170]="MAX dewpoint min=-85.0 max=50.0 unit=°C type=FLOAT offset=0.0"
kanal_spec[170]="AVG dewpoint min=-85.0 max=50.0 unit=°C type=FLOAT offset=0.0"
kanal_spec[115]="AKT dewpoint min=-121.0 max=122.0 unit=°F type=FLOAT offset=0.0"
kanal_spec[135]="MIN dewpoint min=-121.0 max=122.0 unit=°F type=FLOAT offset=0.0"
kanal_spec[155]="MAX dewpoint min=-121.0 max=122.0 unit=°F type=FLOAT offset=0.0"
kanal_spec[175]="AVG dewpoint min=-121.0 max=122.0 unit=°F type=FLOAT offset=0.0"
kanal_spec[200]="AKT relative_humidity min=0.0 max=100.0 unit=% type=FLOAT offset=±30.0"
kanal_spec[220]="MIN relative_humidity min=0.0 max=100.0 unit=% type=FLOAT offset=±30.0"
kanal_spec[240]="MAX relative_humidity min=0.0 max=100.0 unit=% type=FLOAT offset=±30.0"
kanal_spec[260]="AVG relative_humidity min=0.0 max=100.0 unit=% type=FLOAT offset=±30.0"
kanal_spec[205]="AKT absolute_humidity min=0.0 max=85.0 unit=g/m³ type=FLOAT offset=0.0"
kanal_spec[225]="MIN absolute_humidity min=0.0 max=85.0 unit=g/m³ type=FLOAT offset=0.0"
kanal_spec[245]="MAX absolute_humidity min=0.0 max=85.0 unit=g/m³ type=FLOAT offset=0.0"
kanal_spec[265]="AVG absolute_humidity min=0.0 max=85.0 unit=g/m³ type=FLOAT offset=0.0"
kanal_spec[300]="AKT abs. air pressure min=300.0 max=1200.0 unit=hPa type=FLOAT offset=±10.0"
kanal_spec[320]="MIN abs. air pressure min=300.0 max=1200.0 unit=hPa type=FLOAT offset=±10.0"
kanal_spec[340]="MAX abs. air pressure min=300.0 max=1200.0 unit=hPa type=FLOAT offset=±10.0"
kanal_spec[360]="AVG abs. air pressure min=300.0 max=1200.0 unit=hPa type=FLOAT offset=±10.0"
kanal_spec[305]="AKT abs. air pressure min=300.0 max=1200.0 unit=hPa type=FLOAT offset=0.0"
kanal_spec[325]="MIN abs. air pressure min=300.0 max=1200.0 unit=hPa type=FLOAT offset=0.0"
kanal_spec[345]="MAX abs. air pressure min=300.0 max=1200.0 unit=hPa type=FLOAT offset=0.0"
kanal_spec[365]="AVG abs. air pressure min=300.0 max=1200.0 unit=hPa type=FLOAT offset=0.0"
kanal_spec[10020]="AKT battery voltage min=0.0 max=6.5 unit=V type=FLOAT offset=0.0"
kanal_spec[10040]="MIN battery voltage min=0.0 max=6.5 unit=V type=FLOAT offset=0.0"
kanal_spec[10060]="MAX battery voltage min=0.0 max=6.5 unit=V type=FLOAT offset=0.0"
kanal_spec[10080]="AVG battery voltage min=0.0 max=6.5 unit=V type=FLOAT offset=0.0"

# cmd="31 10" (which channels are available in device?)
if [ "$cmd" == "31" -a "$verc" == "10" -a  "${payload:3:2}" == "16" ]; then
    [[ $verbose == 1 ]] && printf "Kanalabfrage (31 10 16):\n"
    kanalnum=$(echo "LE U8 ${payload:6:2}"|gawk -f $dir_scripts/l2p-datatype-convert.gawk)
    [[ $verbose == 1 ]] && printf "Anzahl verfügbarer Kanäle: %d\n" $kanalnum
    for ((i=0; i<kanalnum; i++)); do
        kanal=$(echo "LE U16 ${payload:9+i*6:5}"|gawk -f $dir_scripts/l2p-datatype-convert.gawk)
        printf "Kanal %d (0x%04x): %s\n" $kanal $kanal "${kanal_spec[$kanal]}"
    done
fi



# cmd="23 10" (online data request, one channel)
if [ "$cmd" == "23" -a "$verc" == "10" ]; then
    [[ $verbose == 1 ]] && printf "Online-Datenabfrage (23 10):\n"
    kanal=$(echo "LE U16 ${payload:3:5}" |gawk -f $dir_scripts/l2p-datatype-convert.gawk)
    [[ $verbose == 1 ]] && printf "Kanal=%d: %s\n" $kanal "${kanal_spec[$kanal]}"
    
    datentyp="${payload:9:2}"
    [[ $verbose == 1 ]] && printf "Datentyp=[0x%s]\n" "$datentyp"
    case "$datentyp" in
        16)
            wert=$(echo "LE FLOAT ${payload:12:11}" |gawk -f $dir_scripts/l2p-datatype-convert.gawk)
            format="%f"
            ;;
        *)
            error "Datentyp noch nicht implementiert..."
            ;;
    esac
    [[ $verbose == 1 ]] && printf "Ermittelter Wert: $format\n" "$wert"
    printf "$format" "$wert"

# cmd="23 F0" (online data request, multiple channels)
elif [ "$cmd" == "2F" -a "$verc" == "10" ]; then
    [[ $verbose == 1 ]] && printf "Online-Datenabfrage mehrere Kanäle (2F 10):\n"

    offset=3
    channels=$(echo "LE U8 ${payload:offset:2}" |gawk -f $dir_scripts/l2p-datatype-convert.gawk)
    [[ $verbose == 1 ]] && printf "Kanalanzahl=%d\n" $channels
    (( offset+=3 ))

    for ((i=0; i<$channels; i++)); do
        [[ $verbose == 1 ]] && printf "===Kanal Nr. %d===\n" $i

        sub_len=$(echo "LE U8 ${payload:offset:2}" |gawk -f $dir_scripts/l2p-datatype-convert.gawk)
        [[ $verbose == 1 ]] && printf "\tSubLen=%d (%d) \n" $sub_len $offset
        (( offset+=3 ))
        
        sub_status=$(echo "LE U8 ${payload:offset:2}" |gawk -f $dir_scripts/l2p-datatype-convert.gawk)
        [[ $verbose == 1 ]] && printf "\tSubStatus=%d: (%d) \n" $sub_status $offset
        (( offset+=3 ))
        if [[ $sub_status != 0 ]]; then continue; fi

        kanal=$(echo "LE U16 ${payload:offset:5}" |gawk -f $dir_scripts/l2p-datatype-convert.gawk)
        [[ $verbose == 1 ]] && printf "\tKanal=%d: %s (%d)\n" $kanal "${kanal_spec[$kanal]}" $offset
        (( offset+=6 ))
    
        datentyp="${payload:offset:2}"
        [[ $verbose == 1 ]] && printf "Datentyp=[0x%s]\n" "$datentyp"
        (( offset+=3 ))
        case "$datentyp" in
            16)
                wert=$(echo "LE FLOAT ${payload:offset:11}" |gawk -f $dir_scripts/l2p-datatype-convert.gawk)
                (( offset+=12 ))
                format="%f"
                ;;
            *)
                error "Datentyp noch nicht implementiert..."
                ;;
        esac
        [[ $verbose == 1 ]] && printf "Ermittelter Wert: $format\n" "$wert"
        printf "$format " "$wert"
    done

else
    error "sorry, cmd [$cmd] cannot be analyzed yet."
fi